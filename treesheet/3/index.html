<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
  <!--meta viewport: https://www.npmjs.com/package/@hint/hint-meta-viewport-->
  <!--meta name="viewport" content="width=device-width, initial-scale=1.0"-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#182034">
  <link rel="icon" type="image/png" sizes="48x48" href="./images/favicon-48x48.ico  ">
  
  <title>Test Note App</title>
  <!--link rel="stylesheet" href="css/styles.css"-->
  
  <!-- This lets it make as Android app (In Chrome browser menut, Add to Homepage, search on main screen new icon with this app) -->
  <!--meta name="mobile-web-app-capable" content="yes" -->
  <!-- better alternative is: Progressive Web App
    https://addyosmani.com/blog/getting-started-with-progressive-web-apps/
    https://developers.google.com/web/progressive-web-apps/
    examples: https://github.com/hemanth/awesome-pwa?tab=readme-ov-file
    calculator: https://calculator-app-tau.vercel.app/ https://github.com/soransh-singh/calculatorApp-FrontendMentor/blob/main/index.html
  -->

  <!-- PWA -->
  <link rel="manifest" href="app.webmanifest">
  <meta name="theme-color" content="#F47216"> <!-- Android: Chrome, Firefox OS and Opera -->
  <meta name="apple-mobile-web-app-capable" content="yes"> <!-- iOS -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <!-- default, black, black-translucent (takes color from body:background-color) -->

  
  <!--
    body {
      //margin: 0;
      //padding: 0;
      //overflow: hidden;
      height: 100%;
      width: 100%;
    }
  -->
  <style>
    body {
      height: 100%;
      width: 100%;
      margin: 0;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0; bottom: 0;
      left: 0; right: 0;
      width: 100%;
      height: 100%;
    }
    dddcanvas {
      width: 100%;
      height: 100%;

      display: block;
      width: 100vw;
      height: 100vh;
    }
    .editable-box {
      position: absolute;
      border: 1px solid #888;
      padding: 4px;
      font-size: 16px;
      background: #fafafa;
      min-width: 100px;
      min-height: 24px;
      resize: none;
    }
  </style>
</head>
<body>
  <canvas id="fullscreenCanvas"></canvas>
  <textarea id="editableBox" class="editable-box" style="display:none;"></textarea>
  <script type="text/javascript" src="js/pwa.js"></script>
  <script>
    pwaUtil.requestNotificationPermission();
  
    const ResizeSolution = "WINDOW_RESIZER"; // WINDOW_RESIZER | RESIZE_OBSERVER

    var possibleContexts = ['bitmaprenderer', '2d', 'webgl', 'webgl2', 'experimental-webgl', 'experimental-webgl2', 'dummy'];
    var availableContexts = possibleContexts.filter(function(c) {
      var canvas = document.createElement('canvas');
      if (canvas.getContext(c)) { return c; }
    });
  
    //alert('available contexts: ' + availableContexts);
  
    const canvas = document.getElementById('fullscreenCanvas');
    const ctx = canvas.getContext('2d');
    const editableBox = document.getElementById('editableBox');
    
    const circles = [
      {x:70,y:100,r:30,c:'green'},
      {x:140,y:100,r:30,c:'red'},
      {x:210,y:100,r:30,c:'yellow'},
      {x:280,y:100,r:30,c:'pink'},
      {x:90,y:30,r:20,c:'black'},
      {x:140,y:150,r:30,c:'blue'}
    ];
    
    var textLabel1 = "<empty>";
    
    var isScrolling = false;
    var scrollLeft=0, scrollTop=0;
    var touchStartX=0, touchStartY=0;
    var scrollLeftStart=0, scrollTopStart=0;
    
    // Example drawing
    function draw() {

      ctx.save();
      ctx.fillStyle = 'white';//'skyblue';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // line
      /*ctx.strokeStyle = "grey";//"#0077cc";
      ctx.lineWidth = 0.5;
      //ctx.beginPath();
      //ctx.moveTo(100, 100);
      //ctx.lineTo(400, 200);
      //ctx.closePath();
      //ctx.stroke();
      ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);*/
      
      ctx.restore();
      
      render(canvas, ctx, scrollLeft, scrollTop);

      // text
      ctx.save();
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#000';
      ctx.fillText("v0.12", canvas.width-108, 180);
      ctx.fillText(`dpx:${devicePixelRatio}`, canvas.width-108, 195);
      ctx.restore();
      
      // circles
      ctx.save();
      for (var i = 0; i < circles.length; i++) {
        const c = circles[i];
        ctx.fillStyle = c.c;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#000';
      ctx.fillText(textLabel1, 70, canvas.height - 30);
      ctx.restore();
    }

    function resizeCanvas() {
      //alert('aserser');
      //canvas.width = window.innerWidth;
      //canvas.height = window.innerHeight;
      
      // Get the device pixel ratio, falling back to 1.
      var dpr = devicePixelRatio;
      // Get the size of the canvas in CSS pixels.
      var rect = canvas.getBoundingClientRect();
      // Give the canvas pixel dimensions of their CSS
      // size * the device pixel ratio.
      canvas.width = rect.width * devicePixelRatio;
      canvas.height = rect.height * devicePixelRatio;
      var ctx = canvas.getContext('2d');
      // Scale all drawing operations by the dpr, so you
      // don't have to worry about the difference.
      //ctx.scale(dpr, dpr);

      draw();
    }
    
    function showEditableBox() {
      //const editableBox = document.getElementById('editableBox');
      editableBox.style.display = 'block';
      editableBox.style.left = '20px';
      editableBox.style.top = '200px';
      editableBox.style.width = '200px';
      editableBox.style.height = '30px';
      editableBox.value = "Simple text here";
    }
    
    function hideEditableBox() {
      //const editableBox = document.getElementById('editableBox');
      editableBox.style.display = 'none';
    }
    
    async function onCanvasMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX*devicePixelRatio - rect.left;
      const my = e.clientY*devicePixelRatio - rect.top;
      //alert('x: ' + mx + ', y: ' + my);
      let circleClicked = false;
      for (var i = 0; i < circles.length; i++) {
        const c = circles[i];
        const dx = mx - c.x;
        const dy = my - c.y;
        if (dx*dx + dy*dy <= c.r*c.r) {
          circleClicked = true;
          // handler for circle #i
          if (i === 0) {
            // clicked on green circle
            showEditableBox();
          } else if (i === 1) {
            // clicked on red circle
            hideEditableBox();
          } else if (i === 2) {
            // https://developer.mozilla.org/en-US/docs/Web/API/Clipboard
            const data = new Blob(["TT[778]MM[77]|This is app specific version" + Math.random()], { type: 'text/html' });
            const item = new ClipboardItem({'text/html': data, 'text/plain': 'jkhlasdjkfhsdlfsdfh' + Math.random()});
            /*const clipboardItemData = {
              ["ttt/mywebnotesapp"]: "TT[778]MM[77]|This is app specific version",
              [type]: "This is simple text version"
            };*/
            await navigator.clipboard.write([item]);
            /*navigator.clipboard.writeText("Dummy text to copy to cpbrd").then(() => {
            }).catch(err => {
              alert("failed to copy: " + err);
            });*/
          } else if (i === 3) {
            const clipboardContents = await navigator.clipboard.read(['text/html']); // to prevent sanitization
            for (const item of clipboardContents) {
              for (const mimeType of item.types) {
                if (mimeType === 'text/html') {
                  const blob = item.getType('text/html');
                  blob.then((b) => {
                    for (let key in b) {
                      console.log(`${key}: ${b[key]}`);
                    }
                    //console.log(b.arrayBuffer());
                    b.text().then((t) => { textLabel1 = t; draw(); } );
                  });
                  /*showEditableBox();
                  const editableBox = document.getElementById('editableBox');
                  editableBox.value = blob;*/
                }
              }
            }
          } else if (i === 4) {
            window.close();
          } else if (i === 5) {
            pwaUtil.sendTestPictureNotification();
          }
        }
      }
      if (!circleClicked) {
        // start scrolling
        isScrolling = true;
        touchStartX = mx; touchStartY = my;
        scrollLeftStart = scrollLeft; scrollTopStart = scrollTop;
      }
    }
    
    function onCanvasTouchStart(e) {
      const touch = e.touches[0];
      onCanvasMouseDown(touch);
    }
    
    function onCanvasTouchMove(e) {
      if (isScrolling) {
        e.preventDefault();
        const touch = e.touches[0];

        const rect = canvas.getBoundingClientRect();
        const mx = touch.clientX*devicePixelRatio - rect.left;
        const my = touch.clientY*devicePixelRatio - rect.top;

        scrollLeft = scrollLeftStart + touchStartX - mx;
        scrollTop = scrollTopStart + touchStartY - my;
        console.log(`mx: ${mx}`);
        draw();
      }
    }

    function onCanvasTouchEnd(e) {
      if (isScrolling) {
        isScrolling = false;
      }
    }
    
    function onEditableBoxInput() {
      editableBox.style.height = 'auto';
      editableBox.style.height = Math.min(editableBox.scrollHeight, 60) + 'px';
    }
    
    
    window.addEventListener("load", ()=>{
      canvas.addEventListener('mousedown', onCanvasMouseDown);
      canvas.addEventListener('touchstart', onCanvasTouchStart, {passive: false});
      canvas.addEventListener('touchmove', onCanvasTouchMove, {passive: false});
      canvas.addEventListener('touchend', onCanvasTouchEnd, {passive: false});

      editableBox.addEventListener('input', onEditableBoxInput);

      if (ResizeSolution === "WINDOW_RESIZER") {
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
      } else if (ResizeSolution === "RESIZE_OBSERVER") {
        const observer = new ResizeObserver((entries) => {
          const entry = entries.find((entry) => entry.target === canvas);
          canvas.width = entry.devicePixelContentBoxSize[0].inlineSize * 2;
          canvas.height = entry.devicePixelContentBoxSize[0].blockSize * 2;
          /* … render to canvas … */
          draw();
        });
        observer.observe(canvas, {box: ['device-pixel-content-box']});
      }


      
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("js/service-worker.js")
          .then((registration) => console.log("Service worker registered"))
          .catch((error) => console.log("Service worker registration failed!", error));
      }
      
    });
    
  </script>
  <!--script type="text/javascript" src="js/main.js"></script-->
  <script type="text/javascript" src="js/render.js"></script>
</body>
</html>